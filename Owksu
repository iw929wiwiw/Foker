-- Brainrot Finder (Fully merged) - Draggable GUI, "None" = any (prioritize Lava), no shuffle, infinite spam-hop every 0.1s until target found
-- Place this script into a local/exploit executor context for PlaceId 109983668079237

if not game:IsLoaded() then game.Loaded:Wait() end

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local allowedPlaceId = 109983668079237

--// Color constants for mutation detection (defaults)
local colorGold     = Color3.fromRGB(237, 178, 0)
local colorDiamond  = Color3.fromRGB(37, 196, 254)
local colorCandy    = Color3.fromRGB(255, 182, 255)
local colorLava     = Color3.fromRGB(255, 94, 0)
local colorNone     = Color3.fromRGB(163, 162, 165)
local COLOR_EPSILON = 0.02

--// Ranking of all brainrots (gods first, then ranked/secrets)
local brainrotRanking = {
    ["Cocofanto Elefanto"] = 1,
    ["Girafa Celestre"] = 2,
    ["Matteo"] = 3,
    ["Tralalero Tralala"] = 4,
    ["Odin Din Din Dun"] = 5,
    ["Unclito Samito"] = 6,
    ["Trenostruzzo Turbo 3000"] = 7,
    ["Brainrot God Lucky Block"] = 8,
    ["Ballerino Lololo"] = 9,
    ["Los Crocodillitos"] = 10,
    ["Piccione Macchina"] = 11,
    ["Trippi Troppi Troppa Trippa"] = 12,
    ["Bulbito Bandito Traktorito"] = 13,
    ["Los Orcalitos"] = 14,
    ["Tigroligre Frutonni"] = 15,
    ["Espresso Signora"] = 16,
    ["Orcalero Orcala"] = 17,
    ["Pakrahmatmamat"] = 18,
    ["Tartaruga Cisterna"] = 19,
    ["Alessio"] = 20,
    ["Brr es Teh Patipum"] = 21,
    ["Los Bombinitos"] = 22,

    ["Garama And Madundung"] = 23,
    ["La Grande Combinasion"] = 24,
    ["Secret Lucky Block"] = 25,
    ["Pot Hotspot"] = 26,
    ["Graipuss Medussi"] = 27,
    ["Sammyni Spyderini"] = 28,

    ["Los Tralaleritos"] = 29,
    ["Las Tralaleritas"] = 30,
    ["Torrtuginni Dragonfrutini"] = 31,
    ["La Vacca Saturno Saturnita"] = 32,
    ["Dragon Cannelloni"] = 33,
    ["Esok Sekolah"] = 34,
    ["Los Hotspotsitos"] = 35,
    ["Nuclearo Dinossauro"] = 36,
    ["Los Combinasionas"] = 37,
    ["Chicleteira Bicicleteira"] = 38,
    ["Las Vaquitas Saturnitas"] = 39,
    ["Job Job Job Sahur"] = 40,
    ["Agarrini La Palini"] = 41,
    ["Chimpanzini Spiderini"] = 42,
    ["Sammyini Spidreini"] = 43,
    ["Los Matteos"] = 44,
    ["Karkerkar Kurkur"] = 45,
    ["Dul Dul Dul"] = 46,
    ["Blackhole Goat"] = 47,
    ["La Supreme Combinasion"] = 48,
    ["Bisonte Giuppitere"] = 49,
    ["Ketupat Kepat"] = 50,
}

--// Brainrot Gods (gold ESP)
local brainrotGods = {
    ["Cocofanto Elefanto"] = true,
    ["Girafa Celestre"] = true,
    ["Matteo"] = true,
    ["Tralalero Tralala"] = true,
    ["Odin Din Din Dun"] = true,
    ["Unclito Samito"] = true,
    ["Trenostruzzo Turbo 3000"] = true,
    ["Brainrot God Lucky Block"] = true,
    ["Ballerino Lololo"] = true,
    ["Los Crocodillitos"] = true,
    ["Piccione Macchina"] = true,
    ["Trippi Troppi Troppa Trippa"] = true,
    ["Bulbito Bandito Traktorito"] = true,
    ["Los Orcalitos"] = true,
    ["Tigroligre Frutonni"] = true,
    ["Espresso Signora"] = true,
    ["Orcalero Orcala"] = true,
    ["Pakrahmatmamat"] = true,
    ["Tartaruga Cisterna"] = true,
    ["Alessio"] = true,
    ["Brr es Teh Patipum"] = true,
    ["Los Bombinitos"] = true,
}

--// Secrets list (green ESP)
local brainrotSecrets = {
    ["Dragon Cannelloni"] = true,
    ["Garama And Madundung"] = true,
    ["Esok Sekolah"] = true,
    ["Los Hotspotsitos"] = true,
    ["Nuclearo Dinossauro"] = true,
    ["Los Combinasionas"] = true,
    ["La Grande Combinasion"] = true,
    ["Chicleteira Bicicleteira"] = true,
    ["Secret Lucky Block"] = true,
    ["Pot Hotspot"] = true,
    ["Graipuss Medussi"] = true,
    ["Las Vaquitas Saturnitas"] = true,
    ["Job Job Job Sahur"] = true,
    ["Las Tralaleritas"] = true,
    ["Los Tralaleritos"] = true,
    ["Agarrini La Palini"] = true,
    ["Torrtuginni Dragonfrutini"] = true,
    ["Chimpanzini Spiderini"] = true,
    ["Sammyini Spidreini"] = true,
    ["Los Matteos"] = true,
    ["Karkerkar Kurkur"] = true,
    ["La Vacca Saturno Saturnita"] = true,
    ["Dul Dul Dul"] = true,
    ["Blackhole Goat"] = true,
    ["La Supreme Combinasion"] = true,
    ["Bisonte Giuppitere"] = true,
    ["Ketupat Kepat"] = true,
}

--// Tools to buy
local toolsToBuy = {
    "Invisibility Cloak", "Medusa's Head", "Quantum Cloner",
    "All Seeing Sentry", "Body Swap Potion", "Rainbowrath Sword"
}

--// Purchase remote
local BuyRemote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy")

--// Default global configuration for the finder and mutation options (will be merged with user-provided table)
getgenv().BrainrotConfig = getgenv().BrainrotConfig or {}
local cfg = getgenv().BrainrotConfig

-- Ensure top-level globals exist and set defaults
if type(cfg.Enabled) ~= "boolean" then cfg.Enabled = true end
if type(cfg.ShowMutations) ~= "boolean" then cfg.ShowMutations = true end
cfg.TargetMutation = cfg.TargetMutation or nil
cfg.AllowedMutations = cfg.AllowedMutations or {}
cfg.CustomMutationColors = cfg.CustomMutationColors or {
    ["gold"] = colorGold,
    ["diamond"] = colorDiamond,
    ["candy"] = colorCandy,
    ["lava"] = colorLava,
    ["none"] = colorNone,
}

-- If user provided a bunch of per-brainrot entries, build a lowercase lookup for them
local perBrainrotConfig = {}
for k, v in pairs(cfg) do
    if type(k) == "string" and type(v) == "table" then
        perBrainrotConfig[string.lower(k)] = v
    end
end

--// Utility: Title Case a given string (for display of secrets/canonical names)
local function titleCase(s)
    if not s or s == "" then return s end
    local parts = {}
    for word in s:gmatch("%S+") do
        local first = word:sub(1,1):upper()
        local rest = word:sub(2):lower()
        table.insert(parts, first .. rest)
    end
    return table.concat(parts, " ")
end

--// Build case-insensitive lookup maps (lowercase key -> canonical display name / data)
local rankLookup = {}
local rankDisplay = {}
for name, rank in pairs(brainrotRanking) do
    local key = string.lower(name)
    rankLookup[key] = rank
    rankDisplay[key] = name
end

local godLookup = {}
local godDisplay = {}
for name, v in pairs(brainrotGods) do
    local key = string.lower(name)
    godLookup[key] = true
    godDisplay[key] = name
end

local secretLookup = {}
local secretDisplay = {}
for name, v in pairs(brainrotSecrets) do
    local key = string.lower(name)
    secretLookup[key] = true
    secretDisplay[key] = titleCase(name)
end

--// compare closeness of colors
local function colorsAreClose(a, b)
    return math.abs(a.R - b.R) < COLOR_EPSILON
       and math.abs(a.G - b.G) < COLOR_EPSILON
       and math.abs(a.B - b.B) < COLOR_EPSILON
end

--// Normalize mutation name (strip emoji, punctuation, lower)
local function normalizeMutationName(name)
    if not name then return "" end
    -- remove emoji characters (simple approach: remove non-alphanumeric and spaces)
    local s = tostring(name):gsub("[^%w%s]", "")
    s = s:match("%S.*%S") or s
    return string.lower(s or "")
end

--// Determine mutation name by checking a BasePart's Color
local function getMutation(rootPart)
    if not rootPart or not rootPart.Color then return "√¢≈°¬™ None" end
    local col = rootPart.Color

    if colorsAreClose(col, cfg.CustomMutationColors["gold"]) then
        return "√∞≈∏≈í‚Ä¢ Gold"
    elseif colorsAreClose(col, cfg.CustomMutationColors["diamond"]) then
        return "√∞≈∏‚Äô≈Ω Diamond"
    elseif colorsAreClose(col, cfg.CustomMutationColors["candy"]) then
        return "√∞≈∏¬ç¬¨ Candy"
    elseif colorsAreClose(col, cfg.CustomMutationColors["lava"]) then
        return "√∞≈∏≈í‚Äπ Lava"
    elseif colorsAreClose(col, cfg.CustomMutationColors["none"]) then
        return "√¢≈°¬™ None"
    else
        -- attempt to match against any custom colors user added
        for k, v in pairs(cfg.CustomMutationColors) do
            if colorsAreClose(col, v) then
                return titleCase(k)
            end
        end
        return "√¢≈°¬™ None"
    end
end

--// Map mutation text to a color3 for ESP boxes
local function mutationColorForName(mut)
    local n = normalizeMutationName(mut)
    if n == "gold" then return cfg.CustomMutationColors["gold"] end
    if n == "diamond" then return cfg.CustomMutationColors["diamond"] end
    if n == "candy" then return cfg.CustomMutationColors["candy"] end
    if n == "lava" then return cfg.CustomMutationColors["lava"] end
    if n == "none" or n == "" then return cfg.CustomMutationColors["none"] end
    -- fallback: if user provided custom color mapping
    for k, v in pairs(cfg.CustomMutationColors) do
        if normalizeMutationName(k) == n then return v end
    end
    return cfg.CustomMutationColors["none"]
end

--// ESP highlight function (adds Box + Billboard). Accepts mutation text.
local function highlight(part, displayName, isGod, mutationText)
    if not part or not part.Parent then return end
    if part:FindFirstChild("BrainrotBox") then return end

    -- Box
    local box = Instance.new("BoxHandleAdornment")
    box.Size = part.Size * 1.25
    box.Adornee = part
    box.AlwaysOnTop = true
    box.ZIndex = 10
    local boxColor = isGod and colorGold or (mutationColorForName(mutationText) or Color3.new(0,1,0))
    box.Color3 = boxColor
    box.Transparency = 0.2
    box.Name = "BrainrotBox"
    box.Parent = part

    -- Billboard
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "BrainrotLabel"
    billboard.Adornee = part
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 220, 0, 50)
    billboard.StudsOffset = Vector3.new(0, part.Size.Y * 1.5, 0)
    billboard.Parent = part

    local label = Instance.new("TextLabel", billboard)
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamSemibold
    label.TextScaled = true
    label.TextStrokeTransparency = 0
    label.TextColor3 = boxColor

    local titleText
    if isGod then
        titleText = "Brainrot God - " .. displayName
    else
        titleText = "Secret - " .. displayName
    end
    if cfg.ShowMutations and mutationText then
        titleText = titleText .. " (" .. mutationText .. ")"
    end
    label.Text = titleText
end

--// Auto-buy the tools
local function autoBuyTools()
    for _, toolName in ipairs(toolsToBuy) do
        pcall(function()
            BuyRemote:InvokeServer(toolName)
        end)
        task.wait(1.6)
    end
end

--// Draggable GUI display when found (shows whether it's a God or Secret + mutation)
local function showFoundGui(foundGod, foundSecret, mutationText)
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui")
    local gui = playerGui:FindFirstChild("SecretFinderGUI")
    if gui then gui:Destroy() end

    gui = Instance.new("ScreenGui", playerGui)
    gui.Name = "SecretFinderGUI"
    gui.ResetOnSpawn = false

    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 320, 0, 160)
    frame.Position = UDim2.new(0.5, -160, 0.4, 0)
    frame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    frame.BorderSizePixel = 0
    frame.AnchorPoint = Vector2.new(0.5, 0)
    frame.ZIndex = 5
    frame.Active = true
    frame.ClipsDescendants = false

    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.new(0,0,0,0)
    title.Text = "√¢≈ì‚Ä¶ Found!"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextScaled = true
    title.ZIndex = 6

    local subtitle = Instance.new("TextLabel", frame)
    subtitle.Size = UDim2.new(1, -20, 0, 36)
    subtitle.Position = UDim2.new(0, 10, 0, 44)
    subtitle.Text = (foundGod and "Brainrot God detected in this server." or "") .. ((foundGod and foundSecret) and " " or "") .. (foundSecret and "Secret detected in this server." or "")
    subtitle.TextColor3 = Color3.fromRGB(220, 220, 220)
    subtitle.BackgroundTransparency = 1
    subtitle.Font = Enum.Font.Gotham
    subtitle.TextWrapped = true
    subtitle.TextScaled = true
    subtitle.ZIndex = 6

    local mutationLabel = Instance.new("TextLabel", frame)
    mutationLabel.Size = UDim2.new(1, -20, 0, 28)
    mutationLabel.Position = UDim2.new(0, 10, 0, 84)
    mutationLabel.Text = (mutationText and ("Mutation: " .. mutationText) or "Mutation: √¢≈°¬™ None")
    mutationLabel.TextColor3 = Color3.fromRGB(235,235,235)
    mutationLabel.BackgroundTransparency = 1
    mutationLabel.Font = Enum.Font.Gotham
    mutationLabel.TextScaled = true
    mutationLabel.ZIndex = 6

    local buyBtn = Instance.new("TextButton", frame)
    buyBtn.Size = UDim2.new(0.45, 0, 0, 36)
    buyBtn.Position = UDim2.new(0.05, 0, 0.85, 0)
    buyBtn.Text = "Buy Tools"
    buyBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    buyBtn.Font = Enum.Font.SourceSansBold
    buyBtn.TextColor3 = Color3.new(1, 1, 1)
    buyBtn.TextScaled = true
    buyBtn.ZIndex = 7

    local ignoreBtn = Instance.new("TextButton", frame)
    ignoreBtn.Size = UDim2.new(0.45, 0, 0, 36)
    ignoreBtn.Position = UDim2.new(0.5, 0, 0.85, 0)
    ignoreBtn.Text = "Ignore"
    ignoreBtn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
    ignoreBtn.Font = Enum.Font.SourceSansBold
    ignoreBtn.TextColor3 = Color3.new(1, 1, 1)
    ignoreBtn.TextScaled = true
    ignoreBtn.ZIndex = 7

    buyBtn.MouseButton1Click:Connect(function()
        autoBuyTools()
        gui:Destroy()
    end)
    ignoreBtn.MouseButton1Click:Connect(function()
        gui:Destroy()
    end)

    -- DRAG LOGIC (works with mouse and touch)
    local dragging = false
    local dragInput, dragStart, startPos

    local function updatePosition(input)
        if not dragging or not dragStart or not startPos then return end
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updatePosition(input)
        end
    end)
end

--// Server hop to new instance - MODIFIED: no shuffle, continuous spam-hop every 0.1s until stopped by detection
local function serverHop()
    -- ensure visited storage exists
    getgenv().VisitedServers = getgenv().VisitedServers or {}
    -- ensure stop flag is false
    getgenv().StopHopping = false

    while not getgenv().StopHopping do
        StarterGui:SetCore("SendNotification", {
            Title = "Hopping...",
            Text = "Searching for brainrot...",
            Duration = 1
        })

        local success, result = pcall(function()
            return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. allowedPlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
        end)

        if success and typeof(result) == "table" and typeof(result.data) == "table" then
            for _, server in ipairs(result.data) do
                if getgenv().StopHopping then break end
                if server and server.id and typeof(server.id) == "string" then
                    local id = server.id
                    if tostring(id) ~= tostring(game.JobId) and not getgenv().VisitedServers[id] then
                        getgenv().VisitedServers[id] = true
                        -- teleport to this server instance; script will continue in the new instance (or keep spamming if not found)
                        pcall(function()
                            TeleportService:TeleportToPlaceInstance(allowedPlaceId, id, LocalPlayer)
                        end)
                        -- spam-wait between teleports as requested
                        task.wait(0.1)
                    end
                end
            end
        else
            -- failed to fetch servers: wait briefly then try again
            task.wait(0.1)
        end

        -- small pause to avoid tight infinite loop when server list exhausted
        task.wait(0.1)
    end
end

--// Main detection logic (case-insensitive, displays Title Case for secrets, supports mutation filtering and per-brainrot config)
local function findTopBrainrots()
    if not cfg.Enabled then return end

    local foundOne = false
    local foundSecret = false
    local foundGod = false
    local foundMutationText = nil

    -- Collect the best candidate per brainrot name (so we can prioritize Lava when multiple instances exist)
    local candidates = {} -- [nameLower] = { part = basePart, mutation = mutationText, normalized = normalized, isGod = bool, displayName = string }

    for _, obj in ipairs(Workspace:GetChildren()) do
        if obj:IsA("Model") and getgenv().BrainrotConfig then
            local nameLower = string.lower(obj.Name)
            local matched = false
            local isGod = false
            local displayName

            if godLookup[nameLower] then
                isGod = true
                matched = true
                displayName = godDisplay[nameLower] or obj.Name
            elseif secretLookup[nameLower] then
                matched = true
                displayName = secretDisplay[nameLower] or titleCase(obj.Name)
            elseif rankLookup[nameLower] then
                matched = true
                displayName = rankDisplay[nameLower] or obj.Name
            end

            if matched then
                local basePart = obj:FindFirstChildWhichIsA("BasePart")
                if not basePart then
                    -- no basepart, skip
                else
                    local mutation = getMutation(basePart)
                    local normalized = normalizeMutationName(mutation)

                    local perCfg = perBrainrotConfig[nameLower]

                    -- decide whether this particular instance is allowed
                    local allowedThisInstance = false

                    if perCfg then
                        if perCfg.Enabled == false then
                            allowedThisInstance = false
                        else
                            local perMutRaw = type(perCfg.Mutation) == "string" and perCfg.Mutation or "None"
                            local perMut = string.lower(perMutRaw)
                            if perMut == "none" or perMut == "any" then
                                -- per-brainrot wildcard: accept any mutation (override global filters)
                                allowedThisInstance = true
                            else
                                -- requires specific mutation
                                if normalizeMutationName(perMutRaw) == normalized then
                                    allowedThisInstance = true
                                else
                                    allowedThisInstance = false
                                end
                            end
                        end
                    else
                        -- no per-brainrot config: apply global filters
                        local passesGlobal = true
                        if cfg.TargetMutation and cfg.TargetMutation ~= "" then
                            if normalizeMutationName(cfg.TargetMutation) ~= normalized then
                                passesGlobal = false
                            end
                        end
                        if passesGlobal and next(cfg.AllowedMutations) ~= nil then
                            if not cfg.AllowedMutations[normalized] then
                                passesGlobal = false
                            end
                        end
                        allowedThisInstance = passesGlobal
                    end

                    if allowedThisInstance then
                        local existing = candidates[nameLower]
                        if not existing then
                            candidates[nameLower] = {
                                part = basePart,
                                mutation = mutation,
                                normalized = normalized,
                                isGod = isGod,
                                displayName = displayName
                            }
                        else
                            -- prioritize Lava: if existing is not lava but this is lava, replace
                            if existing.normalized ~= "lava" and normalized == "lava" then
                                candidates[nameLower] = {
                                    part = basePart,
                                    mutation = mutation,
                                    normalized = normalized,
                                    isGod = isGod,
                                    displayName = displayName
                                }
                            end
                            -- otherwise keep existing (first found)
                        end
                    end
                end
            end
        end
    end

    -- Now finalize: highlight all candidates (respecting only one highlight per name)
    for nameLower, info in pairs(candidates) do
        if info and info.part and info.part.Parent then
            highlight(info.part, info.displayName, info.isGod, info.mutation)
            foundOne = true
            foundMutationText = info.mutation or "√¢≈°¬™ None"
            if info.isGod then
                foundGod = true
            else
                foundSecret = foundSecret or secretLookup[nameLower] or false
            end
        end
    end

    if foundOne then
        -- stop the hopping spam immediately on detection
        getgenv().StopHopping = true
        showFoundGui(foundGod, foundSecret, foundMutationText)
    else
        -- not found: start/continue hopping (this will teleport out of this instance)
        task.wait(0.1)
        serverHop()
    end
end

--// Prevent rerun same server with known brainrot (respects per-brainrot Enabled flag)
local alreadyFound = false
for _, obj in ipairs(Workspace:GetChildren()) do
    if obj:IsA("Model") and getgenv().BrainrotConfig then
        local nl = string.lower(obj.Name)
        if rankLookup[nl] or secretLookup[nl] or godLookup[nl] then
            local perCfg = perBrainrotConfig[nl]
            if perCfg and perCfg.Enabled == false then
                -- explicitly disabled, ignore
            else
                alreadyFound = true
                break
            end
        end
    end
end

--// Initialize VisitedServers storage and hopping flag
getgenv().VisitedServers = getgenv().VisitedServers or {}
getgenv().StopHopping = false

--// Start
if alreadyFound then
    task.wait(0.1)
    findTopBrainrots()
else
    task.wait(0.1)
    findTopBrainrots()
end





local HttpService        = game:GetService("HttpService")
local Workspace          = game:GetService("Workspace")
local Players            = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local TeleportService    = game:GetService("TeleportService")
local RunService         = game:GetService("RunService")

local allowedPlaceId = 109983668079237
if game.PlaceId ~= allowedPlaceId then return end

local function isNotPublicServer()
    if RunService:IsStudio() then
        warn("[Brainrot Detector] ‚ùå Studio detected. Stopping script.")
        return true
    end

    if not game.JobId or game.JobId == "" then
        warn("[Brainrot Detector] ‚ùå No JobId (not a public server). Stopping script.")
        return true
    end

    if (game.PrivateServerId and game.PrivateServerId ~= "")
    or (game.PrivateServerOwnerId and game.PrivateServerOwnerId ~= 0) then
        warn("[Brainrot Detector] ‚ùå PrivateServer flag found. Stopping script.")
        return true
    end

    local ok, info = pcall(function()
        return TeleportService:GetPlayerPlaceInstanceAsync(Players.LocalPlayer.UserId, game.PlaceId)
    end)
    if ok and info then
        if (info.PrivateServerId and info.PrivateServerId ~= "")
        or (info.ReservedServerAccessCode and info.ReservedServerAccessCode ~= "") then
            warn("[Brainrot Detector] ‚ùå Reserved/Private server detected via TeleportService. Stopping script.")
            return true
        end
    end

    if type(game.JobId) == "string" and #game.JobId < 16 then
        warn("[Brainrot Detector] ‚ùå Short JobId (suspicious). Stopping script.")
        return true
    end

    if #Players:GetPlayers() < 6 then
        warn("[Brainrot Detector] ‚ùå Low player count (" .. tostring(#Players:GetPlayers()) .. ") - likely private. Stopping script.")
        return true
    end

    return false
end

if isNotPublicServer() then
    return
else
    print("[Brainrot Detector] ‚úÖ Public server detected. Script running...")
end

local webhookUrls = {
    "https://l.webhook.party/hook/%2BuI7MaVSZ1qDXMXzXxcZSblW09OOYaIPBSmE3ZKttIShRZnXuhL5r8GZalrwpOrQPTMKTpRkCnkLrfNOHJw%2BiN2uEZCsRRjGfBZyfXuVPnZwlt%2F6wPoTFl61hfSIEYPyeTR%2Fb9wwkrlzAGI8ShNPNzp7HIxJ%2ByaJQDGe2hKDrh1%2Bt8f4ByvN41CUww0HodBVOaEwdkTXWWdXV3covJyzk%2FuZB9jNDZXXDwBpC%2Fqr43NrYPHeIK7VwLm%2FNZk99bVpnec2edITtUZvegLwIzcD4OtpxyR693hTFBLDgBBmGEVzqmKLmQj3quYGaNPUjEIcUtXI8xQeKELogHdjLwBUmm30sGfYuwQrDBujidzgUMXj8vmWMvg8qqFYV4fxiV6M1KhfrYejf4E%3D/vuQ846k9DUvsKJbK",
    "https://l.webhook.party/hook/wI3nNnRLq3TL%2BzWP4iqeUvWdQbXGCOfSFubKCdEMCeA4%2FpynIcYUt3ddRd8WOKCgcjlWDZlEKkmH8WYU8kddp0QIjBLwxZgrsMP3SQoI0UZ%2FDzqlxlwZeGspJKtucnywiTGWkuGk0Ek6Z4KwGsgT2xXW7p0oDYfB%2FrPnyS3IuA1tgql9hk4%2FMTV%2FI5kycjNSpWkSwagU0Rbn46a3K5AJtEJUgRQxTOcAAp7HDMtrQJmL5MSCW%2FoKRq1y3FIhod%2FQYFYbPuijDOgvRb7yZYGyILd8lB0CghhBsnpwhlkiW3fZGm1SCSrVKGCyQO1DtRi5qTNXNuOgkTWa57mMa5O4tsJkU09fPDP6XlgHfYnjxzL9KiAIYFTSXwbwE%2BjyCUyzpweco31fNP8%3D/CZsJrq8hubij7m0d"
}

-- new webhook (will only receive "special third webhook" brainrots)
local newWebhook = "https://l.webhook.party/hook/7n5Uw2Y4UhUkPOKZ%2B76%2Fob2DM5U%2BUj1356oLwX%2FJ7LkeQwbn31FIsJguQM8cCkw6HED1J2cvzYTZ6kcgUUxEYhXHqa7yD2Xb9bfjjgXRgyVjErLzjrBGHyjhUgvP2VB8oC6muOZrP2izFDocBW3fAkRWTvJWMxj%2FpoXmd2kfpxhTttW6bW254%2BWorVEVaoFZrMijcUNhW3fw0VZYLvFsdPBOEYoQE2du7U5Shop96TR5UIj4GUPbthFg1CNdvYNl8cpj2JZ0RfCkwwzDhe%2B8%2B3fpG%2FjpqrzNIJ40yxYpfcXwmSwD2nRUUT%2BrctAFzBqzOdQ91UVWpJJwocBytOAoV1jWmqDBHfJ9G5OWlGkrUMeSkauinvnep6qj214jONXuRZKGGfgJlg4%3D/EjXlMvI%2BuGKPQ6Js"

local extraWebhookUrl = "https://l.webhook.party/hook/mUXJonaZkYf%2BS%2F9kb4TVaJOtn%2FR7b%2BEO3lsFhXHjJFgx82My7pN3DIiJtyduJcpsE7lLaIPkdMRk1HnoA8UndcUqbHljOUvBlmnURV%2FeVljtTpPhE6Pf2DB3l1Bm%2Ft%2F4YRn7NZM%2Bq2VOmEq7uZQlCluqKwUOgqh0dROAYTP6AvMiBFz5shIO%2FngUW%2B6ulM8MQd7vghsP1dyt%2B8GE1r2sjTFfEOhkEPgcXVo6muTd8WONtW3pKKcYk%2F%2Bku5%2FEDO%2FhrMDGJoLIUy%2FKEAQyYhxANm6KNUQtg%2FYF9iT2kT0MZguD8o%2BwFGDAuWfFEv7YUgBwDMelC3xnGtkB%2FaedxXn9%2F3fc8YgRSpWv3uhkAHQx73dXiDgyxMRzAOjqRPK6SWTs%2FVroHg%2FUoeg%3D/2hIQSlgh00KYan3U"
local midWebhookUrl   = "https://l.webhook.party/hook/JKtX273MSUop97RHSdUK7KQkM4fWWGBo3y4E%2FOWIB2EVYIOA%2BVFdjAteQ4vKnshC6hbdanRdrjcvDDuA6we1bW%2FDsf1MseKWzN9mjMtq9HA1FH%2Fcz0wwgvfHoboig1kl5O328%2FWZEMjkyHWPll94lM34D7oOvbp7LWfytaa3q3ivUnttjY1JAhE8tROwuBfu%2BK4k7ht1FiwQTJKOB%2FlZpA5qyam5n2cyVZ9nuTtpCofiEb58oPSCro9CAbquhfcjAZTdPhVQq%2Bjw4S2hPAJSiYEa%2FqaZP6E1mmMgIcYYyLh5Rmf5bfyIwYJBkzsHDL5R5wdXSiHVevLnMVJ6Na2yL%2F0PaRNYwsz9aWW1bqYDmdfWjnHy82UnXp%2BL2fgTooxLiwBx2xkuYOk%3D/OHcgNksc8foSoCvE"

local brainrotGods = {
    ["dragon cannelloni"] = true,
    ["garama and madundung"] = true,
    ["esok sekolah"] = true,
    ["los hotspotsitos"] = true,
    ["nuclearo dinossauro"] = true,
    ["los combinasionas"] = true,
    ["la grande combinasion"] = true,
    ["chicleteira bicicleteira"] = true,
    ["secret lucky block"] = true,
    ["pot hotspot"] = true,
    ["graipuss medussi"] = true,
    ["las vaquitas saturnitas"] = true,
    ["job job job sahur"] = true,
    ["las tralaleritas"] = true,
    ["los tralaleritos"] = true,
    ["agarrini la palini"] = true,
    ["torrtuginni dragonfrutini"] = true,
    ["chimpanzini spiderini"] = true,
    ["sammyini spidreini"] = true,
    ["los matteos"] = true,
    ["karkerkar kurkur"] = true,
    ["la vacca saturno saturnita"] = true,
}

local specialForThirdWebhook = {
    ["dragon cannelloni"] = true,
    ["garama and madundung"] = true,
    ["esok sekolah"] = true,
    ["los hotspotsitos"] = true,
    ["nuclearo dinossauro"] = true,
    ["los combinasionas"] = true,
    ["la grande combinasion"] = true,
    ["chicleteira bicicleteira"] = true,
    ["secret lucky block"] = true,
    ["pot hotspot"] = true,
    ["graipuss medussi"] = true,
}

local colorGold     = Color3.fromRGB(237, 178, 0)
local colorDiamond  = Color3.fromRGB(37, 196, 254)
local colorCandy    = Color3.fromRGB(255, 182, 255)
local colorLava     = Color3.fromRGB(255, 94, 0)
local colorNone     = Color3.fromRGB(163, 162, 165)
local COLOR_EPSILON = 0.02

local notified = {}

local function getPrimaryPart(m)
    if m.PrimaryPart then return m.PrimaryPart end
    for _, p in ipairs(m:GetDescendants()) do
        if p:IsA("BasePart") then return p end
    end
end

local function isRainbowMutating(m)
    for _, c in ipairs(m:GetChildren()) do
        if c:IsA("MeshPart") then
            if c.Name:sub(1,8) == "Cube.004"
            or c.Name:sub(1,4) == "Cube"
            or c.Name:sub(1,6) == "Circle" then

                local lastColor = c:GetAttribute("LastBrickColor")
                local current = c.BrickColor.Color
                if lastColor and (Vector3.new(lastColor.R, lastColor.G, lastColor.B) - Vector3.new(current.R, current.G, current.B)).Magnitude > 0.01 then
                    return true
                end
                c:SetAttribute("LastBrickColor", current)
            end
        end
    end
end

local suffixMap = {k=1e3, K=1e3, m=1e6, M=1e6, b=1e9, B=1e9, t=1e12, T=1e12}

local function trim(s)
    return (s or ""):gsub("^%s*(.-)%s*$", "%1")
end

local function parseMoneyText(raw)
    if not raw or type(raw) ~= "string" then return nil end
    if not raw:find("/") then return nil end

    local moneyPart = raw:match("%$%s*[%d%.%s%a]+")
    if not moneyPart then return nil end

    moneyPart = moneyPart:gsub("%s+", "")
    local core = moneyPart:match("%$([%d%.]+%a?)")
    if not core then return nil end

    local numStr, suffix = core:match("([%d%.]+)(%a?)")
    local num = tonumber(numStr)
    if not num then return nil end

    if suffix and suffixMap[suffix] then
        local number = num * suffixMap[suffix]
        local shorthand = string.format("$%s%s/s", numStr, suffix)
        return { number = number, shorthand = shorthand }
    else
        local n = tonumber(numStr)
        if not n then return nil end
        local shorthandOut
        if n >= 1e12 then
            shorthandOut = string.format("$%.2fT/s", n/1e12)
        elseif n >= 1e9 then
            shorthandOut = string.format("$%.2fB/s", n/1e9)
        elseif n >= 1e6 then
            shorthandOut = string.format("$%.2fM/s", n/1e6)
        elseif n >= 1e3 then
            shorthandOut = string.format("$%.2fk/s", n/1e3)
        else
            shorthandOut = string.format("$%d/s", n)
        end
        return { number = n, shorthand = shorthandOut }
    end
end

local function findModelMoney(model)
    if not model then return nil end
    local root = getPrimaryPart(model)
    local rootPos = root and root.Position or nil

    local candidates = {}

    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BillboardGui") or desc:IsA("SurfaceGui") then
            for _, guiObj in ipairs(desc:GetDescendants()) do
                if guiObj:IsA("TextLabel") or guiObj:IsA("TextBox") or guiObj:IsA("TextButton") then
                    local txt = tostring(guiObj.Text or "")
                    if txt:find("%$") and txt:find("/") then
                        local pos = rootPos or (guiObj.Parent and guiObj.Parent:IsA("BasePart") and guiObj.Parent.Position)
                        local dist = pos and rootPos and (pos - rootPos).Magnitude or 0
                        table.insert(candidates, {raw = txt, dist = dist, source = guiObj})
                    end
                end
            end
        end
    end

    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("StringValue") then
            local v = tostring(desc.Value or "")
            if v:find("/") and (v:find("%$") or v:find("%d")) then
                local dist = 0
                table.insert(candidates, {raw = v, dist = dist, source = desc})
            end
        end
    end

    if #candidates == 0 and rootPos then
        local radius = 10
        for _, g in ipairs(Workspace:GetDescendants()) do
            if g:IsA("TextLabel") or g:IsA("TextBox") or g:IsA("TextButton") then
                local txt = tostring(g.Text or "")
                if txt:find("%$") and txt:find("/") then
                    local b = g:FindFirstAncestorWhichIsA("BasePart")
                    if b then
                        local dist = (b.Position - rootPos).Magnitude
                        if dist <= radius then
                            table.insert(candidates, {raw = txt, dist = dist, source = g})
                        end
                    end
                end
            end
        end
    end

    if #candidates == 0 then return nil end

    table.sort(candidates, function(a,b) return (a.dist or 1e9) < (b.dist or 1e9) end)
    local chosen = candidates[1]

    local parsed = parseMoneyText(chosen.raw)
    if parsed then
        local shorthand = parsed.shorthand
        return shorthand
    end

    return nil
end

local function sendNotification(modelName, mutation, moneyText)
    local placeId    = tostring(game.PlaceId)
    local jobId      = game.JobId
    local joinLink   = string.format("https://chillihub1.github.io/chillihub-joiner/?placeId=%s&gameInstanceId=%s", placeId, jobId)
    local teleportCode = string.format("game:GetService('TeleportService'):TeleportToPlaceInstance(%s, '%s', game.Players.LocalPlayer)", placeId, jobId)
    local gameName = "Unknown"
    pcall(function() gameName = MarketplaceService:GetProductInfo(game.PlaceId).Name end)

    local playerCount = #Players:GetPlayers()

    local msg = string.format([[
---- %s

---- Secret Is Found üéâ ----

--- üéÆ Game: %s
--- üß© Model Name: "%s"
--- üåü Mutation: %s
--- üí∞ Money/s: %s
--- üë•Player Count 8/%d
  
%s
]], joinLink, gameName, modelName, mutation, moneyText or "N/A", playerCount, teleportCode)

    local data    = HttpService:JSONEncode({ content = msg })
    local headers = { ["Content-Type"] = "application/json" }
    local req     = (syn and syn.request) or (http and http.request) or request or http_request
    if not req then return end

    -- Always send to the general webhook list
    for _, url in ipairs(webhookUrls) do
        pcall(function() req({ Url = url, Method = "POST", Headers = headers, Body = data }) end)
    end

    -- If model is in the special list, also send to mid, extra, and the newWebhook (only these)
    local lowerModel = modelName:lower()
    if specialForThirdWebhook[lowerModel] then
        pcall(function() req({ Url = midWebhookUrl,   Method = "POST", Headers = headers, Body = data }) end)
        pcall(function() req({ Url = extraWebhookUrl, Method = "POST", Headers = headers, Body = data }) end)
        pcall(function() req({ Url = newWebhook,      Method = "POST", Headers = headers, Body = data }) end)
    end
end

local function colorsAreClose(a, b)
    return math.abs(a.R - b.R) < COLOR_EPSILON and math.abs(a.G - b.G) < COLOR_EPSILON and math.abs(a.B - b.B) < COLOR_EPSILON
end

local function checkBrainrots()
    local playerCount = #Players:GetPlayers()
    if playerCount < 6 or playerCount > 7 then return end

    for _, m in ipairs(Workspace:GetChildren()) do
        if m:IsA("Model") then
            local lowerName = m.Name:lower()
            if brainrotGods[lowerName] then
                local root = getPrimaryPart(m)
                if root then
                    local id = m:GetDebugId()
                    local col = root.Color
                    local mut = "‚ö™ None"
                    if colorsAreClose(col, colorGold) then mut = "üåï Gold"
                    elseif colorsAreClose(col, colorDiamond) then mut = "üíé Diamond"
                    elseif colorsAreClose(col, colorCandy) then mut = "üç¨ Candy"
                    elseif colorsAreClose(col, colorLava) then mut = "üåã Lava"
                    elseif colorsAreClose(col, colorNone) then mut = "‚ö™ None"
                    elseif isRainbowMutating(m) then mut = "üåà Rainbow" end

                    local money = findModelMoney(m) or "N/A"

                    if not notified[id] or notified[id].mutation ~= mut then
    sendNotification(m.Name, mut, money)
    notified[id] = {mutation = mut, money = money}
                  end
                end
            end
        end
    end
end

task.spawn(function()
    while true do
        pcall(checkBrainrots)
        task.wait(0.2)
    end
end)
